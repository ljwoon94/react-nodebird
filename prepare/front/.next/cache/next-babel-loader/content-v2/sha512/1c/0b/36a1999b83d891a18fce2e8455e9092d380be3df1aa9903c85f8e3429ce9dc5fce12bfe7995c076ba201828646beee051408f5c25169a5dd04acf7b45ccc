{"ast":null,"code":"import _regeneratorRuntime from \"C:/job/react-nodebird/prepare/front/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(rootSaga);\n\nimport { all, fork } from 'redux-saga/effects';\nimport axios from 'axios';\nimport postSaga from './post';\nimport userSaga from './user';\naxios.defaults.baseURL = 'http://localhost:3065'; //sagas 의 post url를 등록\n\naxios.defaults.withCredentials = true; //쿠기 전달 허용 이제 saga에 공통적으로 적용된다.\n\nexport default function rootSaga() {\n  return _regeneratorRuntime.wrap(function rootSaga$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return all([//all은 함수를 동시에 실행시킴\n          fork(postSaga), fork(userSaga) // fork는 비동기 함수를 실행하는 것\n          // 요청을 보내버리고 결과를 기다리지 않고 다음 것이 실행됨\n          // call은 동기 함수를 실행하는 것\n          // 결과를 기다렸다 다음 것이 실행됨. \n          ]);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // generate 함수 function*\n// const gen = function*(){\n// console.log(1);\n// yield;\n// console.log(2);\n// yield;   \n//}\n//\n// const generator = gen();\n// generator.next()  generate함수를 실행시키려면 next()필요\n// console.log(1)실행. 다시 generator 함수를 실행하면\n// console.log(2)실행 generate는 yield가 나오는 곳에서 멈춤\n// 중단점이 있는 함수. 이것이 saga\n// done: true가 나오면 멈춤\n//\n// generate 함수로 무한 표현하기\n// let i = 0;\n// const gen = function* () {\n//     while (true) {\n//         yield i++;\n//     }\n// }\n// const g= gen();\n// g.next();","map":{"version":3,"sources":["C:/job/react-nodebird/prepare/front/sagas/index.js"],"names":["rootSaga","all","fork","axios","postSaga","userSaga","defaults","baseURL","withCredentials"],"mappings":";;oDAUyBA,Q;;AAVzB,SAASC,GAAT,EAAcC,IAAd,QAA0B,oBAA1B;AACA,OAAOC,KAAP,MAAkB,OAAlB;AAEA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAEAF,KAAK,CAACG,QAAN,CAAeC,OAAf,GAAyB,uBAAzB,C,CACA;;AACAJ,KAAK,CAACG,QAAN,CAAeE,eAAf,GAAiC,IAAjC,C,CACA;;AACA,eAAe,SAAUR,QAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACX,iBAAMC,GAAG,CAAC,CACN;AACAC,UAAAA,IAAI,CAACE,QAAD,CAFE,EAGNF,IAAI,CAACG,QAAD,CAHE,CAIN;AACA;AACA;AACA;AAPM,WAAD,CAAT;;AADW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAWX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { all, fork } from 'redux-saga/effects';\r\nimport axios from 'axios';\r\n\r\nimport postSaga from './post';\r\nimport userSaga from './user';\r\n\r\naxios.defaults.baseURL = 'http://localhost:3065';\r\n//sagas 의 post url를 등록\r\naxios.defaults.withCredentials = true;\r\n//쿠기 전달 허용 이제 saga에 공통적으로 적용된다.\r\nexport default function* rootSaga() {\r\n    yield all([\r\n        //all은 함수를 동시에 실행시킴\r\n        fork(postSaga),\r\n        fork(userSaga),\r\n        // fork는 비동기 함수를 실행하는 것\r\n        // 요청을 보내버리고 결과를 기다리지 않고 다음 것이 실행됨\r\n        // call은 동기 함수를 실행하는 것\r\n        // 결과를 기다렸다 다음 것이 실행됨. \r\n    ]);\r\n}\r\n    // generate 함수 function*\r\n    // const gen = function*(){\r\n    // console.log(1);\r\n    // yield;\r\n    // console.log(2);\r\n    // yield;   \r\n    //}\r\n    //\r\n    // const generator = gen();\r\n    // generator.next()  generate함수를 실행시키려면 next()필요\r\n    // console.log(1)실행. 다시 generator 함수를 실행하면\r\n    // console.log(2)실행 generate는 yield가 나오는 곳에서 멈춤\r\n    // 중단점이 있는 함수. 이것이 saga\r\n    // done: true가 나오면 멈춤\r\n    //\r\n    // generate 함수로 무한 표현하기\r\n    // let i = 0;\r\n    // const gen = function* () {\r\n    //     while (true) {\r\n    //         yield i++;\r\n    //     }\r\n    // }\r\n    // const g= gen();\r\n    // g.next();"]},"metadata":{},"sourceType":"module"}